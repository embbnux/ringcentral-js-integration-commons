{"version":3,"sources":["modules/RecentMessages/index.js"],"names":["RecentMessages","client","messageStore","options","actionTypes","_client","_messageStore","_reducer","addSelector","messages","reduce","unreadCounts","contactId","acc","cur","readStatus","_prevMessageStoreTimestamp","store","subscribe","_onStateChange","pending","ready","dispatch","type","initSuccess","resetSuccess","length","updatedTimestamp","contacts","contact","getMessages","currentContact","fromLocal","forceUpdate","id","initLoad","_getRecentMessages","loadSuccess","loadReset","daySpan","dateFrom","recentMessages","_getLocalRecentMessages","dateTo","creationTime","undefined","_fetchRemoteRecentMessages","toISOString","concat","_dedup","slice","phoneNumbers","message","matches","i","find","_filterPhoneNumber","Date","push","phoneNumber","from","to","extensionNumber","params","messageType","perPage","recentMessagesPromise","promise","_fetchMessageList","then","_flattenToMessageRecords","_markAsRemoteMessage","_sortMessages","account","extension","list","allMessages","records","sort","a","b","map","fromRemote","hash","state","_selectors","unreadMessageCounts","messageStatus","loaded","status"],"mappings":"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","file":"index.js","sourcesContent":["import proxify from '../../lib/proxy/proxify';\nimport ensureExist from '../../lib/ensureExist';\nimport RcModule from '../../lib/RcModule';\nimport actionTypes from './actionTypes';\nimport messageStatus from './messageStatus';\nimport getRecentMessagesReducer from './getRecentMessagesReducer';\nimport getDateFrom from '../../lib/getDateFrom';\nimport concurrentExecute from '../../lib/concurrentExecute';\n\n/**\n * @class\n * @description Retrieve all recent messages related to a specified contact.\n */\nexport default class RecentMessages extends RcModule {\n  /**\n   * @constructor\n   * @param {Object} params - params object\n   * @param {MessageStore} params.messageStore - messageStore module instance\n   * @param {Client} params.client - client module instance\n   */\n  constructor({\n    client,\n    messageStore,\n    ...options\n  }) {\n    super({\n      actionTypes,\n      ...options\n    });\n    this._client = this::ensureExist(client, 'client');\n    this._messageStore = this::ensureExist(messageStore, 'messageStore');\n    this._reducer = getRecentMessagesReducer(this.actionTypes);\n\n    this.addSelector(\n      'unreadMessageCounts',\n      () => this.messages,\n      messages => (\n        Object.keys(messages).reduce((unreadCounts, contactId) => {\n          unreadCounts[contactId] = messages[contactId]\n            .reduce((acc, cur) => acc + (cur.readStatus !== 'Read' ? 1 : 0), 0);\n          return unreadCounts;\n        }, {})\n      )\n    );\n\n    this._prevMessageStoreTimestamp = null;\n  }\n\n  initialize() {\n    this.store.subscribe(() => this._onStateChange());\n  }\n\n  _onStateChange() {\n    if (\n      this.pending &&\n      this._messageStore.ready\n    ) {\n      this.store.dispatch({\n        type: this.actionTypes.initSuccess,\n      });\n    } else if (\n      this.ready &&\n      !this._messageStore.ready\n    ) {\n      this.store.dispatch({\n        type: this.actionTypes.resetSuccess\n      });\n    } else if (Object.keys(this.messages).length > 0) {\n      // Listen to messageStore state changes\n      if (this._messageStore.updatedTimestamp !== this._prevMessageStoreTimestamp) {\n        this._prevMessageStoreTimestamp = this._messageStore.updatedTimestamp;\n        for (const contact of Object.values(this.contacts)) {\n          this.getMessages(contact, false, true);\n        }\n      }\n    }\n  }\n\n  get contacts() {\n    return this.state.contacts;\n  }\n\n  get messages() {\n    return this.state.messages;\n  }\n\n  get unreadMessageCounts() {\n    return this._selectors.unreadMessageCounts();\n  }\n\n  get isMessagesLoaded() {\n    return this.state.messageStatus === messageStatus.loaded;\n  }\n\n  @proxify\n  async getMessages(currentContact, fromLocal = false, forceUpdate = false) {\n    // No need to calculate recent messages of the same contact repeatly\n    if (!currentContact) {\n      return;\n    }\n    if (\n      !forceUpdate &&\n      !!this.messages[currentContact.id]\n    ) {\n      return;\n    }\n    this._prevMessageStoreTimestamp = this._messageStore.updatedTimestamp;\n    this.store.dispatch({\n      type: this.actionTypes.initLoad\n    });\n    const messages = await this._getRecentMessages(\n      currentContact,\n      this._messageStore.messages,\n      fromLocal\n    );\n    this.store.dispatch({\n      type: this.actionTypes.loadSuccess,\n      messages,\n      contact: currentContact\n    });\n  }\n\n  cleanUpMessages(contact) {\n    this.store.dispatch({\n      type: this.actionTypes.loadReset,\n      contact\n    });\n  }\n\n  get status() {\n    return this.state.status;\n  }\n\n  /**\n   * Searching for recent messages of specific contact.\n   * @param {Object} currentContact - Current contact\n   * @param {Array} messages - Messages in messageStore\n   * @param {Boolean} fromLocal - Only get recent messages locally\n   * @param {Number} daySpan - Find messages within certain days\n   * @param {Number} length - Maximum length of recent messages\n   * @return {Array}\n   * @private\n   */\n  async _getRecentMessages(currentContact, messages = [], fromLocal, daySpan = 60, length = 5) {\n    const dateFrom = getDateFrom(daySpan);\n    let recentMessages = this._getLocalRecentMessages(\n      currentContact,\n      messages,\n      dateFrom,\n      length\n    );\n\n    // If we could not find enough recent messages,\n    // we need to search for messages on server.\n    if (!fromLocal && recentMessages.length < length) {\n      const dateTo = recentMessages.length > 0\n        ? recentMessages[recentMessages.length - 1].creationTime\n        : undefined;\n\n      // This will always be sorted\n      recentMessages = recentMessages.concat(\n        await this._fetchRemoteRecentMessages(\n          currentContact,\n          dateFrom.toISOString(),\n          dateTo,\n          length\n        )\n      );\n    }\n\n    recentMessages = this._dedup(recentMessages);\n    return recentMessages.length > length\n      ? recentMessages.slice(0, length)\n      : recentMessages;\n  }\n\n  /**\n   * Get recent messages from messageStore.\n   * @param {Object} currentContact\n   * @param {Array} messages\n   * @param {Date} dateFrom\n   * @param {Number} length\n   */\n  _getLocalRecentMessages(currentContact, messages, dateFrom, length) {\n    // Get all messages related to this contact\n    const phoneNumbers = currentContact.phoneNumbers;\n    const recentMessages = [];\n    let message;\n    let matches;\n    for (let i = messages.length - 1; i >= 0; i -= 1) {\n      message = messages[i];\n      matches = phoneNumbers.find(this._filterPhoneNumber(message));\n\n      // Check if message is within certain days\n      if (!!matches && new Date(message.creationTime) > dateFrom) {\n        recentMessages.push(message);\n      }\n      if (recentMessages.length >= length) break;\n    }\n    return recentMessages;\n  }\n\n  _filterPhoneNumber(message) {\n    return ({ phoneNumber }) => (\n      phoneNumber === message.from.phoneNumber ||\n      !!message.to.find(to => to.phoneNumber === phoneNumber) ||\n      phoneNumber === message.from.extensionNumber ||\n      !!message.to.find(to => to.extensionNumber === phoneNumber)\n    );\n  }\n\n  /**\n   * Fetch recent messages from server by given current contact.\n   * @param {Object} currentContact\n   * @param {String} dateFrom\n   * @param {String} dateTo\n   * @param {Number} length The number of messages\n   * @return {Array}\n   */\n  _fetchRemoteRecentMessages(\n    currentContact,\n    dateFrom,\n    dateTo = (new Date()).toISOString(),\n    length\n  ) {\n    const params = {\n      dateTo,\n      dateFrom,\n      messageType: ['SMS', 'Text', 'Pager'],\n      perPage: length\n    };\n    const phoneNumbers = currentContact.phoneNumbers;\n    const recentMessagesPromise = phoneNumbers.reduce((acc, { phoneNumber }) => {\n      if (phoneNumber) {\n        const promise = this._fetchMessageList(\n          Object.assign({}, params, {\n            phoneNumber\n          })\n        );\n        return acc.concat(promise);\n      }\n      return acc;\n    }, []);\n\n    // TODO: Because we need to navigate to the message page,\n    // So we may need to push new messages to messageStore\n    return concurrentExecute(recentMessagesPromise, 5, 500)\n      .then(this._flattenToMessageRecords)\n      .then(this._markAsRemoteMessage)\n      .then(messages => this._sortMessages(messages));\n  }\n\n  _fetchMessageList(params) {\n    return () => this._client.account().extension().messageStore().list(params);\n  }\n\n  _countUnreadMessages(messages) {\n    return messages.reduce((acc, cur) => acc + (cur.readStatus !== 'Read' ? 1 : 0), 0);\n  }\n\n  _flattenToMessageRecords(allMessages) {\n    return allMessages.reduce((acc, { records }) => acc.concat(records), []);\n  }\n\n  _sortMessages(recentMessages) {\n    // Sort by time in descending order\n    return recentMessages.sort((a, b) =>\n      new Date(b.creationTime) - new Date(a.creationTime)\n    );\n  }\n\n  _markAsRemoteMessage(messages) {\n    return messages.map((message) => {\n      message.fromRemote = true;\n      return message;\n    });\n  }\n\n  _dedup(messages) {\n    const hash = {};\n    return messages.reduce((acc, cur) => {\n      if (hash[cur.id]) return acc;\n      hash[cur.id] = true;\n      return acc.concat(cur);\n    }, []);\n  }\n}\n"]}