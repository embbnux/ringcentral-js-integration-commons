{"version":3,"sources":["lib/LoggerBase/index.js"],"names":["defaultIdentityFunction","convertListToMap","item","id","loggingList","mapping","forEach","name","LoggerBase","actionTypes","base","prefix","getReducer","identityFunction","options","_name","_identityFunction","_reducer","_logPromises","_logProviders","addSelector","logFn","readyCheckFn","Error","constructor","has","set","store","subscribe","_onStateChange","pending","logProvidersReady","ready","_shouldInit","dispatch","type","init","_onInit","initSuccess","_shouldReset","reset","_onReset","resetSuccess","key","get","log","promise","delete","logSuccess","logError","error","_log","all","keys","map","values","every","provider","state","status","_selectors","loggingMap"],"mappings":"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","file":"index.js","sourcesContent":["import RcModule from '../RcModule';\nimport { prefixEnum } from '../Enum';\nimport ensureExist from '../ensureExist';\n\nimport moduleStatuses from '../../enums/moduleStatuses';\nimport baseActionTypes from './baseActionTypes';\nimport getDefaultReducer from './getDefaultReducer';\n\n/**\n * @function defaultIdentityFunction\n * @description Identity function returns a deterministic id value for each item.\n * @param {Object} item\n * @return {String}\n */\nexport function defaultIdentityFunction(item) {\n  return item.id;\n}\n\n/**\n * @function\n * @description Convert array of { name, id } objects into a map.\n * @param {[{ name: String, id: String }]} loggingList\n * @return {{ [ids]: { [names]: true } }}\n */\nexport function convertListToMap(loggingList) {\n  const mapping = {};\n  loggingList.forEach((item) => {\n    if (!mapping[item.id]) {\n      mapping[item.id] = {\n        [item.name]: true,\n      };\n    } else {\n      mapping[item.id][item.name] = true;\n    }\n  });\n  return mapping;\n}\n\n/**\n * @class\n * @description Base class implementation for loggers.\n */\nexport default class LoggerBase extends RcModule {\n  /**\n   * @constructor\n   * @param {String} params.name - name of the class\n   * @param {Object} params.actionTypes\n   * @param {Function} params.getReducer\n   * @param {Function} params.identityFunction - function that can derive an unique\n   *    id from items.\n   */\n  constructor({\n    name,\n    actionTypes = prefixEnum({ base: baseActionTypes, prefix: name }),\n    getReducer = getDefaultReducer,\n    identityFunction = defaultIdentityFunction,\n    ...options,\n  }) {\n    super({\n      ...options,\n      actionTypes,\n    });\n    this._name = this::ensureExist(name, 'name');\n    this._identityFunction = this::ensureExist(identityFunction, 'identityFunction');\n\n    this._reducer = getReducer(this.actionTypes);\n\n    this._logPromises = new Map();\n    this._logProviders = new Map();\n\n    this.addSelector('loggingMap',\n      () => this.loggingList,\n      convertListToMap,\n    );\n  }\n\n  addLogProvider({\n    name,\n    logFn,\n    readyCheckFn,\n    ...options,\n  } = {}) {\n    if (!name) {\n      throw new Error(\n        `${this.constructor.name}: \"name\" is required.`\n      );\n    }\n    if (this._logProviders.has(name)) {\n      throw new Error(\n        `${this.constructor.name}: A provider named \"${name}\" already exists.`\n      );\n    }\n    if (typeof logFn !== 'function') {\n      throw new Error(\n        `${this.constructor.name}: \"logFn\" must be a function.`\n      );\n    }\n    if (typeof readyCheckFn !== 'function') {\n      throw new Error(\n        `${this.constructor.name}: \"readyCheckFn\" must be a function.`\n      );\n    }\n    this._logProviders.set(name, {\n      logFn,\n      readyCheckFn,\n      ...options,\n    });\n  }\n\n  get logProvidersReady() {\n    return [...this._logProviders.values()]\n      .every(provider => provider.readyCheckFn());\n  }\n\n  initialize() {\n    this.store.subscribe(() => this._onStateChange());\n  }\n\n  _shouldInit() {\n    return this.pending &&\n      this.logProvidersReady;\n  }\n  _shouldReset() {\n    return this.ready &&\n      !this.logProvidersReady;\n  }\n\n  async _onStateChange() {\n    if (this._shouldInit()) {\n      this.store.dispatch({\n        type: this.actionTypes.init,\n      });\n      if (typeof this._onInit === 'function') {\n        await this._onInit();\n      }\n      this.store.dispatch({\n        type: this.actionTypes.initSuccess,\n      });\n    } else if (this._shouldReset()) {\n      this.store.dispatch({\n        type: this.actionTypes.reset,\n      });\n      if (typeof this._onReset === 'function') {\n        await this._onReset();\n      }\n      this.store.dispatch({\n        type: this.actionTypes.resetSuccess,\n      });\n    }\n  }\n\n  async _log({ item, name, ...options } = {}) {\n    if (!this.ready) {\n      throw new Error(`${this.constructor.name}._log: module is not ready.`);\n    }\n    if (!item) {\n      throw new Error(`${this.constructor.name}._log: options.item is undefined.`);\n    }\n    if (!name) {\n      throw new Error(`${this.constructor.name}._log: options.name is undefined.`);\n    }\n    if (!this._logProviders.has(name)) {\n      throw new Error(`${this.constructor.name}._log: provider '${name}' does not exist.`);\n    }\n\n    const id = this._identityFunction(item);\n    const key = `${name}-${id}`;\n    // wait for the previous log action to finish\n    if (this._logPromises.has(key)) {\n      await this._logPromises.get(key);\n    }\n    try {\n      this.store.dispatch({\n        type: this.actionTypes.log,\n        name,\n        id,\n      });\n      const promise = this._logProviders.get(name).logFn({ item, ...options });\n      this._logPromises.set(key, promise);\n      await promise;\n      this._logPromises.delete(key);\n      this.store.dispatch({\n        type: this.actionTypes.logSuccess,\n        name,\n        id,\n      });\n    } catch (error) {\n      this._logPromises.delete(key);\n      this.store.dispatch({\n        type: this.actionTypes.logError,\n        error,\n        name,\n        id,\n      });\n      throw error;\n    }\n  }\n\n  async log({ item, name, ...options }) {\n    if (!this.ready) {\n      throw new Error(`${this.constructor.name}.log: module is not ready.`);\n    }\n    if (!item) {\n      throw new Error(`${this.constructor.name}.log: options.item is undefined.`);\n    }\n\n    if (name) {\n      if (!this._logProviders.has(name)) {\n        throw new Error(`${this.constructor.name}.log: provider '${name}' does not exist.`);\n      }\n      await this._log({ item, name, ...options });\n    } else {\n      await Promise.all(\n        [...this._logProviders.keys()]\n          .map(key => this._log({ item, name: key, ...options }))\n      );\n    }\n  }\n\n  get status() {\n    return this.state.status;\n  }\n\n  get ready() {\n    return this.state.status === moduleStatuses.ready;\n  }\n\n  get pending() {\n    return this.state.status === moduleStatuses.pending;\n  }\n\n  get loggingList() {\n    return this.state.loggingList;\n  }\n\n  get loggingMap() {\n    return this._selectors.loggingMap();\n  }\n\n}\n"]}